#+STARTUP: indent
#+STARTUP: hidestars

#+PROPERTY: header-args :dir target/examples

#+PROPERTY: header-args:java  :cmdline -classpath .;../classes/
#+PROPERTY: header-args:java+ :cmpflag -classpath .;../classes/

** Introduction

Extends [[https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html][java.util.function.Supplier]] with higher-order methods that enable composition of
suppliers and transformation and filtering of the results produced by the functional method ~get~.

** Installation

Requires *Java 8* or higher.

Currently, the main option for installation is [[https://jitpack.io/][Jitpack]]:

#+begin_src
  dependencies {
      implementation 'com.github.nikolavojicic:recipe:<COMMIT-HASH>'
  }
#+end_src

*TODO*: Publish to the /Maven Central Repository/.

** Examples

*** Preparation

**** Compile project

#+begin_src sh :dir . :results none
  mvn clean compile
#+end_src

**** Add imports needed for examples

#+begin_src java :noweb yes :tangle target/examples/Examples.java :classname Examples :results none :exports none
  <<IMPORT>>

  public class Examples {

      // dummy main to avoid auto-generated one
      public static void main(String[] args) {}

      // --------------------------------------

      public static <T> Predicate<T> not(Predicate<T> predicate) {
          return predicate.negate();
      }

      <<STATIC>>

      // --------------------------------------

      public static void example1() {
          <<EXAMPLE_1>>
      }

      public static void example2() {
          <<EXAMPLE_2>>
      }

      public static void example3() {
          <<EXAMPLE_3>>
      }

      public static void example4() {
          <<EXAMPLE_4>>
      }

      public static void example5() {
          <<EXAMPLE_5>>
      }

      public static void example6() {
          <<EXAMPLE_6>>
      }

      public static void example7() {
          <<EXAMPLE_7>>
      }

      public static void example8() {
          <<EXAMPLE_8>>
      }

      public static void example9() {
          <<EXAMPLE_9>>
      }

      public static void example10() {
          <<EXAMPLE_10>>
      }

      public static void example11() {
          <<EXAMPLE_11>>
      }

      public static void example12() {
          <<EXAMPLE_12>>
      }

      public static void example13() {
          <<EXAMPLE_13>>
      }

      public static void example14() {
          <<EXAMPLE_14>>
      }

  }
#+end_src

#+begin_src java :noweb-ref IMPORT :eval never
  import org.recipe.Recipe;
  import org.recipe.exception.RecipeFilterException;
  import org.recipe.util.Pair;

  import static org.recipe.util.Fn.*;

  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.List;
  import java.util.Map;
  import java.util.Objects;
  import java.util.UUID;
  import java.util.concurrent.atomic.AtomicInteger;
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.function.Predicate;
  import java.util.function.Supplier;
  import java.util.stream.Stream;

  import static java.util.Arrays.asList;
  import static java.util.Collections.synchronizedList;
  import static java.util.concurrent.ThreadLocalRandom.current;
#+end_src

*** Creating recipes

Recipe is a functional interface that extends the Supplier interface.
Both of them represent functions that accept nothing and return some value.
These functions are executed by calling their functional method ~get~.

**** Lambda expression

#+begin_src java :noweb-ref EXAMPLE_1 :eval never
  Supplier<String> sup = () -> "foo";
  Recipe  <String> rec = () -> "foo";

  System.out.println(
      sup.get().equals(rec.get())
  );
#+end_src

#+name: EXE_EXAMPLE_1
#+begin_src java :results output :exports results
  Examples.example1();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_1
: true

**** Method reference

#+begin_src java :noweb-ref EXAMPLE_2 :eval never
  Recipe<UUID> rec = UUID::randomUUID;

  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_2
#+begin_src java :results output :exports results
  Examples.example2();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_2
: 96a3732a-70ae-4d4a-9944-4bd39daf0af4
: 5d858623-8653-4c8a-90a9-b7cfdae043a5

**** Function to Recipe

Recipe extends Supplier by providing default methods that enable composition of suppliers
/ recipes and transformation and filtering of the results produced by the method ~get~.

There is no way to chain those default method calls directly on the lambda expression
/ method reference so that the whole definition of a recipe is written as a single
expression. One way to achieve this is to use the static factory method ~of~ as wrapper.

#+begin_src java :noweb-ref STATIC :eval never
  public static final Recipe<String>
      REC_UUID_STR = Recipe
          .of(UUID::randomUUID)
          .map(UUID::toString);
#+end_src

All Recipe's methods that accept other recipes as arguments, accept any extension of the
Supplier instead of the concrete Recipe type. That's why the method ~of~ can also be used
as converter to the Recipe type.

#+begin_src java :noweb-ref EXAMPLE_3 :eval never
  Supplier<UUID>    sup = UUID::randomUUID;
  Recipe  <Integer> rec = Recipe
                            .of(sup)
                            .map(UUID::toString)
                            .map(String::length);

  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_3
#+begin_src java :results output :exports results
  Examples.example3();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_3
: 36

**** Constant Recipe

Recipe that constantly returns the given reference can be created with the static factory method ~ofValue~.

#+begin_src java :noweb-ref EXAMPLE_4 :eval never
  Recipe<List> rec = Recipe
      .ofValue(asList(1, 2, 3));

  System.out.println(
      rec.get() == rec.get()
  );
#+end_src

#+name: EXE_EXAMPLE_4
#+begin_src java :results output :exports results
  Examples.example4();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_4
: true

This method is also useful for creating stateful recipes (provided argument should be thread-safe).

#+begin_src java :noweb-ref EXAMPLE_5 :eval never
  Recipe<Long> rec = Recipe
      .ofValue(new AtomicLong())
      .map(AtomicLong::incrementAndGet);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_5
#+begin_src java :results output :exports results
  Examples.example5();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_5
: 1
: 2
: 3

*** Composing recipes

**** Union

Recipe that randomly chooses a value from two recipes can be created by the method ~or~.

#+begin_src java :noweb-ref EXAMPLE_6 :eval never
  Recipe<Integer> rec = Recipe
      .of(() -> current().nextInt())
      .or(() -> null);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_6
#+begin_src java :results output :exports results
  Examples.example6();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_6
: -1658766505
: 614352061
: null

For a union of variable number of recipes, use the static factory method ~oneOf~.

#+begin_src java :noweb-ref EXAMPLE_7 :eval never
  Recipe<String> rec = Recipe
      .oneOf(() -> "foo",
             REC_UUID_STR,
             Recipe.ofValue("bar"));

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_7
#+begin_src java :results output :exports results
  Examples.example7();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_7
: fa4dab90-3da6-4008-82f2-d84151a75f3b
: foo
: 596afd9a-5117-49b5-b2cf-d78f0036b04f
: bar

**** Filtering

Use the method ~filter~ to create a new recipe that returns only those values, produced by another recipe, that match a predicate.

Predicates can be negated by the operator [[https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html#not(java.util.function.Predicate)][Predicate#not]] available in Java 11+ (but it is trivial to [[https://stackoverflow.com/a/22492361][write]]).

#+begin_src java :noweb-ref EXAMPLE_8 :eval never
  Recipe<Double> rec = Recipe
      .of(() -> current().nextDouble())
      .filter(x -> x > 0)
      .filter(not(x -> x.isInfinite()));

  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_8
#+begin_src java :results output :exports results
  Examples.example8();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_8
: 0.12826014636372696
: 0.3920702845614149

When the given predicate cannot be satisfied after 100 tries, runtime exception ~RecipeFilterException~ is thrown.

#+begin_src java :noweb-ref EXAMPLE_9 :eval never
  Recipe<Integer> rec = Recipe
      .of(() -> current().nextInt())
      .filter(x -> x > 0 && x < 6);

  try {
      rec.get();
  } catch (RecipeFilterException ex) {
      System.out.println(ex.getMessage());
  }
#+end_src

#+name: EXE_EXAMPLE_9
#+begin_src java :results output :exports results
  Examples.example9();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_9
: Couldn't satisfy predicate after 100 tries.

This can be fixed either by improving the underlying recipe (e.g., use ~nextInt(1, 6)~ instead of unbounded ~nextInt()~) or by relaxing the predicate.

**** Transformation

Use the method ~map~ to create a new recipe that applies a function to the values produced by another recipe.

If the given function has side effects, it is often ~void~ or returns some other type that you might want to ignore.
Use the operator [[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/org/recipe/util/Fn.java#L21][Fn#doto]] to apply the function to the object and return that same object.

#+begin_src java :noweb-ref EXAMPLE_10 :eval never
  Recipe<List<Integer>> rec = Recipe
      .ofValue(asList(1, 2, 3, 4, 5))     // unmodifiable list
      .map(ArrayList::new)                // make modifiable copy
      .map(doto(list -> list.add(42)))    // add method returns boolean
      .map(doto(Collections::shuffle))    // shuffle method is void
      .map(Collections::unmodifiableList) // make unmodifiable list
      .map(doto(System.out::println));    // println method is void

  rec.get();
  rec.get();
#+end_src

#+name: EXE_EXAMPLE_10
#+begin_src java :results output :exports results
  Examples.example10();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_10
: [3, 42, 5, 2, 1, 4]
: [2, 5, 3, 1, 4, 42]

**** Binding

Use the method ~bind~ to create a new recipe that takes values produced by two recipes and combines them with a binary function. There are three common cases:

***** Second recipe depends on values produced by the first recipe

For example, recipe that takes a random element from a list - the first recipe produces a list of elements, the second an index based on the size of the produced list. Binary function uses those values to retrieve an element.

#+begin_src java :noweb-ref EXAMPLE_11 :eval never
  Recipe<Object> rec = Recipe
      .oneOf(() -> asList(1, 2, 3, 4),
             () -> asList("foo", "bar", "baz"))
      .bind(list -> () -> current().nextInt(0, list.size()), List::get);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_11
#+begin_src java :results output :exports results
  Examples.example11();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_11
: bar
: baz
: 4

This is a very common pattern. To make it more readable, creation of the second recipe can be written as a method reference, with the help of static method ~recIndex~.

#+begin_src java :noweb-ref STATIC :eval never
  public static Recipe<String>
      REC_EMAIL_DOMAIN = Recipe
          .ofValue(asList("gmail.com", "yahoo.com", "proton.me"))
          .bind(Examples::recIndex, List::get);

  public static Recipe<Integer> recIndex(List<?> list) {
      if (list.isEmpty())
          throw new IllegalArgumentException("empty list");
      return () -> current().nextInt(0, list.size());
  }
#+end_src

If the first recipe depends on the value produced by the second recipe, then swap their order.

***** Recipes do not depend on each other

For example, an email address consists of two parts, a local part and a domain, joined with the symbol ~@~. Both parts can be generated independently. Operator [[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/org/recipe/util/Fn.java#L52][Fn#recfn]] can be used instead of function with ignored argument.

#+begin_src java :noweb-ref EXAMPLE_12 :eval never
  Recipe<String> recEmail =
      REC_UUID_STR
          .map(local -> local.substring(0, 8))
          .bind(recfn(REC_EMAIL_DOMAIN), // __ -> REC_EMAIL_DOMAIN
                (local, domain) -> local + "@" + domain);

  System.out.println(recEmail.get());
  System.out.println(recEmail.get());
#+end_src

#+name: EXE_EXAMPLE_12
#+begin_src java :results output :exports results
  Examples.example12();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_12
: bdd27ccd@gmail.com
: 559c052c@yahoo.com

***** Second recipe produces results of function application

For example, recipe that produces a pair of a list and the maximum element from that list. Operator [[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/org/recipe/util/Fn.java#L64][Fn#fnrec]] can be used to wrap a function so that it returns a constant recipe of its result.

#+begin_src java :noweb-ref EXAMPLE_13 :eval never
  Recipe<Pair<List<Integer>, Integer>> rec = Recipe
      .ofValue(asList(1, 9, 3, 5, 7))
      // list -> Recipe.ofValue(Collections.max(list))
      .bind(fnrec(Collections::max), Pair::new);

  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_13
#+begin_src java :results output :exports results
  Examples.example13();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_13
: Pair[first=[1, 9, 3, 5, 7], second=9]

In any of the cases above, it may happen that the binary function has side effects. Such function is often ~void~ or returns some other type that you might want to ignore. Use the operator [[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/org/recipe/util/Fn.java#L36][Fn#dotwo]] to apply the function to the given objects and return the pair of those objects.

#+begin_src java :noweb-ref EXAMPLE_14 :eval never
  Recipe<List<Integer>> rec = Recipe
      .ofValue(synchronizedList(new ArrayList<Integer>()))
      .bind(recfn(Recipe
                  .ofValue(new AtomicInteger())
                  .map(AtomicInteger::incrementAndGet)),
            dotwo(List::add)) // add returns boolean
      .map(Pair::first)
      // .map(List::copyOf) in Java 10+
      .map(ArrayList::new)
      .map(Collections::unmodifiableList);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_14
#+begin_src java :results output :exports results
  Examples.example14();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_14
: [1]
: [1, 2]
: [1, 2, 3]

**** Flattening

**** Wrapping

*** Generating numbers

*** Generating text

*** Generating POJOs or Records

**** Setters

**** Withers

**** Builders

**** Constructors

*** Dependency injection
