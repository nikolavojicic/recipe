#+STARTUP: indent
#+STARTUP: hidestars

#+PROPERTY: header-args :dir target/examples

#+PROPERTY: header-args:java  :cmdline -classpath .;../classes/
#+PROPERTY: header-args:java+ :cmpflag -classpath .;../classes/

** recipe

Extends [[https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html][java.util.function.Supplier]] with higher-order methods that enable composition of
suppliers and transformation and filtering of the results produced by the functional method ~get~.

** Installation

Requires *Java 8* or higher.

Currently, the main option for installation is [[https://jitpack.io/][Jitpack]]:

#+begin_src
  dependencies {
      implementation 'com.github.nikolavojicic:recipe:<COMMIT-HASH>'
  }
#+end_src

*TODO*: Publish to the /Maven Central Repository/.

** Examples

*** Preparation

**** Compile project

#+begin_src sh :dir . :results none
  mvn clean compile
#+end_src

**** Verify Java version

#+name: VERIFY_JAVA_VERSION
#+begin_src java :results value :exports both
  return System.getProperty("java.version");
#+end_src

> Results ↴
#+RESULTS: VERIFY_JAVA_VERSION
: 17.0.2

**** Add imports needed for examples

#+begin_src java :noweb yes :tangle target/examples/Examples.java :classname Examples :results none :exports none
  <<IMPORT>>

  public class Examples {

      // dummy main to avoid auto-generated one
      public static void main(String[] args) {}

      // --------------------------------------

      <<STATIC>>

      // --------------------------------------

      public static void example1() {
          <<EXAMPLE_1>>
      }

      public static void example2() {
          <<EXAMPLE_2>>
      }

      public static void example3() {
          <<EXAMPLE_3>>
      }

      public static void example4() {
          <<EXAMPLE_4>>
      }

      public static void example5() {
          <<EXAMPLE_5>>
      }

  }
#+end_src

#+begin_src java :noweb-ref IMPORT :eval never
  import org.recipe.Recipe;

  import static org.recipe.util.Fn.*;

  import java.util.Arrays;
  import java.util.List;
  import java.util.Map;
  import java.util.Objects;
  import java.util.UUID;
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.function.Supplier;
  import java.util.stream.Stream;

  import static java.util.concurrent.ThreadLocalRandom.current;
#+end_src

*** Creating recipes

[[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/org/recipe/Recipe.java][Recipe]] is a functional interface that extends the [[https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html][Supplier]] interface.
Both of them represent functions that accept nothing and return some value.
These functions are executed by calling the functional method ~get~.

**** Lambda expression

#+begin_src java :noweb-ref EXAMPLE_1 :eval never
  Supplier<String> sup = () -> "foo";
  Recipe  <String> rec = () -> "foo";

  System.out.println(
      sup.get().equals(rec.get())
  );
#+end_src

#+name: EXE_EXAMPLE_1
#+begin_src java :results output :exports results
  Examples.example1();
#+end_src

> Results ↴
#+RESULTS: EXE_EXAMPLE_1
: true

**** Method reference

#+begin_src java :noweb-ref EXAMPLE_2 :eval never
  Recipe<UUID> rec = UUID::randomUUID;

  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_2
#+begin_src java :results output :exports results
  Examples.example2();
#+end_src

> Results ↴
#+RESULTS: EXE_EXAMPLE_2
: 96a3732a-70ae-4d4a-9944-4bd39daf0af4
: 5d858623-8653-4c8a-90a9-b7cfdae043a5

**** Function -> Recipe

Recipe extends Supplier by providing default methods that enable composition of suppliers
/ recipes and transformation and filtering of the results produced by the method ~get~.

There is no way to chain those default method calls directly on the lambda expression
/ method reference so that the whole definition of a Recipe is written as a single
expression. One way to achieve this is to use the static factory method ~of~ as a wrapper.

#+begin_src java :noweb-ref STATIC :eval never
  public static final Recipe<String>
      REC_UUID_STR = Recipe
          .of(UUID::randomUUID)
          .map(UUID::toString);
#+end_src

All Recipe methods that accept other recipes as arguments, accept any extension of the
Supplier instead of the concrete Recipe type. That's why the method ~of~ can also be used
as a converter to the Recipe type.

#+begin_src java :noweb-ref EXAMPLE_3 :eval never
  Supplier<UUID>    sup = UUID::randomUUID;
  Recipe  <Integer> rec = Recipe
                            .of(sup)
                            .map(UUID::toString)
                            .map(String::length);

  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_3
#+begin_src java :results output :exports results
  Examples.example3();
#+end_src

> Results ↴
#+RESULTS: EXE_EXAMPLE_3
: 36

**** Constant Recipe

Recipe that constantly returns the given reference can be created with the static factory method ~ofValue~.

#+begin_src java :noweb-ref EXAMPLE_4 :eval never
  Recipe<List> rec = Recipe
      .ofValue(Arrays.asList(1, 2, 3));

  System.out.println(
      rec.get() == rec.get()
  );
#+end_src

#+name: EXE_EXAMPLE_4
#+begin_src java :results output :exports results
  Examples.example4();
#+end_src

> Results ↴
#+RESULTS: EXE_EXAMPLE_4
: true

This method is also useful for creating stateful recipes (provided argument should be thread-safe).

#+begin_src java :noweb-ref EXAMPLE_5 :eval never
  Recipe<Long> rec = Recipe
      .ofValue(new AtomicLong())
      .map(AtomicLong::incrementAndGet);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_5
#+begin_src java :results output :exports results
  Examples.example5();
#+end_src

> Results ↴
#+RESULTS: EXE_EXAMPLE_5
: 1
: 2
: 3
