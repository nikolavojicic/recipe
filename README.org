#+STARTUP: indent
#+STARTUP: hidestars

#+PROPERTY: header-args :dir target/examples

#+PROPERTY: header-args:java  :cmdline -classpath .;../classes/
#+PROPERTY: header-args:java+ :cmpflag -classpath .;../classes/

** Introduction

Extends [[https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html][java.util.function.Supplier]] with higher-order methods that enable composition of
suppliers and transformation and filtering of the results produced by the functional method ~get~.

** Installation

Requires *Java 8* or higher.

Currently, the main option for installation is [[https://jitpack.io/][Jitpack]]:

#+begin_src
  dependencies {
      implementation 'com.github.nikolavojicic:recipe:<COMMIT-HASH>'
  }
#+end_src

*TODO*: Publish to the /Maven Central Repository/.

** Examples

*** Preparation

**** Compile project

#+begin_src sh :dir . :results none
  mvn clean compile
#+end_src

**** Verify Java version

#+name: VERIFY_JAVA_VERSION
#+begin_src java :results value :exports both
  return System.getProperty("java.version");
#+end_src

Results:
#+RESULTS: VERIFY_JAVA_VERSION
: 17.0.2

**** Add imports needed for examples

#+begin_src java :noweb yes :tangle target/examples/Examples.java :classname Examples :results none :exports none
  <<IMPORT>>

  public class Examples {

      // dummy main to avoid auto-generated one
      public static void main(String[] args) {}

      // --------------------------------------

      public static <T> Predicate<T> not(Predicate<T> predicate) {
          return predicate.negate();
      }

      <<STATIC>>

      // --------------------------------------

      public static void example1() {
          <<EXAMPLE_1>>
      }

      public static void example2() {
          <<EXAMPLE_2>>
      }

      public static void example3() {
          <<EXAMPLE_3>>
      }

      public static void example4() {
          <<EXAMPLE_4>>
      }

      public static void example5() {
          <<EXAMPLE_5>>
      }

      public static void example6() {
          <<EXAMPLE_6>>
      }

      public static void example7() {
          <<EXAMPLE_7>>
      }

      public static void example8() {
          <<EXAMPLE_8>>
      }

      public static void example9() {
          <<EXAMPLE_9>>
      }

  }
#+end_src

#+begin_src java :noweb-ref IMPORT :eval never
  import org.recipe.Recipe;
  import org.recipe.exception.RecipeFilterException;

  import static org.recipe.util.Fn.*;

  import java.util.Arrays;
  import java.util.List;
  import java.util.Map;
  import java.util.Objects;
  import java.util.UUID;
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.function.Predicate;
  import java.util.function.Supplier;
  import java.util.stream.Stream;

  import static java.util.concurrent.ThreadLocalRandom.current;
#+end_src

*** Creating recipes

[[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/org/recipe/Recipe.java][Recipe]] is a functional interface that extends the [[https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html][Supplier]] interface.
Both of them represent functions that accept nothing and return some value.
These functions are executed by calling the functional method ~get~.

**** Lambda expression

#+begin_src java :noweb-ref EXAMPLE_1 :eval never
  Supplier<String> sup = () -> "foo";
  Recipe  <String> rec = () -> "foo";

  System.out.println(
      sup.get().equals(rec.get())
  );
#+end_src

#+name: EXE_EXAMPLE_1
#+begin_src java :results output :exports results
  Examples.example1();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_1
: true

**** Method reference

#+begin_src java :noweb-ref EXAMPLE_2 :eval never
  Recipe<UUID> rec = UUID::randomUUID;

  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_2
#+begin_src java :results output :exports results
  Examples.example2();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_2
: 96a3732a-70ae-4d4a-9944-4bd39daf0af4
: 5d858623-8653-4c8a-90a9-b7cfdae043a5

**** Function to Recipe

Recipe extends Supplier by providing default methods that enable composition of suppliers
/ recipes and transformation and filtering of the results produced by the method ~get~.

There is no way to chain those default method calls directly on the lambda expression
/ method reference so that the whole definition of a recipe is written as a single
expression. One way to achieve this is to use the static factory method ~of~ as a wrapper.

#+begin_src java :noweb-ref STATIC :eval never
  public static final Recipe<String>
      REC_UUID_STR = Recipe
          .of(UUID::randomUUID)
          .map(UUID::toString);
#+end_src

All Recipe's methods that accept other recipes as arguments, accept any extension of the
Supplier instead of the concrete Recipe type. That's why the method ~of~ can also be used
as a converter to the Recipe type.

#+begin_src java :noweb-ref EXAMPLE_3 :eval never
  Supplier<UUID>    sup = UUID::randomUUID;
  Recipe  <Integer> rec = Recipe
                            .of(sup)
                            .map(UUID::toString)
                            .map(String::length);

  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_3
#+begin_src java :results output :exports results
  Examples.example3();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_3
: 36

**** Constant Recipe

Recipe that constantly returns the given reference can be created with the static factory method ~ofValue~.

#+begin_src java :noweb-ref EXAMPLE_4 :eval never
  Recipe<List> rec = Recipe
      .ofValue(Arrays.asList(1, 2, 3));

  System.out.println(
      rec.get() == rec.get()
  );
#+end_src

#+name: EXE_EXAMPLE_4
#+begin_src java :results output :exports results
  Examples.example4();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_4
: true

This method is also useful for creating stateful recipes (provided argument should be thread-safe).

#+begin_src java :noweb-ref EXAMPLE_5 :eval never
  Recipe<Long> rec = Recipe
      .ofValue(new AtomicLong())
      .map(AtomicLong::incrementAndGet);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_5
#+begin_src java :results output :exports results
  Examples.example5();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_5
: 1
: 2
: 3

*** Composing recipes

**** Union

Recipe that randomly chooses a value from two recipes can be created by the method ~or~.

#+begin_src java :noweb-ref EXAMPLE_6 :eval never
  Recipe<Integer> rec = Recipe
      .of(() -> current().nextInt())
      .or(() -> null);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_6
#+begin_src java :results output :exports results
  Examples.example6();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_6
: -1658766505
: 614352061
: null

For a union of variable number of recipes, use the static factory method ~oneOf~.

#+begin_src java :noweb-ref EXAMPLE_7 :eval never
  Recipe<String> rec = Recipe
      .oneOf(() -> "foo",
             REC_UUID_STR,
             Recipe.ofValue("bar"));

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_7
#+begin_src java :results output :exports results
  Examples.example7();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_7
: fa4dab90-3da6-4008-82f2-d84151a75f3b
: foo
: 596afd9a-5117-49b5-b2cf-d78f0036b04f
: bar

**** Filtering

Use the method ~filter~ to create a new recipe that returns only those values, produced by another recipe, that match the given predicate.
Predicates can be negated by the [[https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html#not(java.util.function.Predicate)][Predicate#not]] operator.

#+begin_src  java :noweb-ref EXAMPLE_8 :eval never
  Recipe<Double> rec = Recipe
      .of(() -> current().nextDouble())
      .filter(x -> x > 0)
      .filter(not(x -> x.isInfinite()));

  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_8
#+begin_src java :results output :exports results
  Examples.example8();
#+end_src

#+RESULTS: EXE_EXAMPLE_8
: 0.12826014636372696
: 0.3920702845614149

If the given predicate cannot be satisfied after 100 tries, runtime exception ~RecipeFilterException~ is thrown.

#+begin_src  java :noweb-ref EXAMPLE_9 :eval never
  Recipe<Integer> rec = Recipe
      .of(() -> current().nextInt())
      .filter(x -> x > 0 && x < 6);

  try {
      rec.get();
  } catch (RecipeFilterException ex) {
      System.out.println(ex.getMessage());
  }
#+end_src

#+name: EXE_EXAMPLE_9
#+begin_src java :results output :exports results
  Examples.example9();
#+end_src

#+RESULTS: EXE_EXAMPLE_9
: Couldn't satisfy predicate after 100 tries.

These problems can be fixed either by improving the underlying recipe or by relaxing the predicate (e.g. use ~current().nextInt(1, 6)~ instead of unbounded ~nextInt()~.

**** Transformation


**** Binding


**** Flattening

**** Lifting

*** Generating POJOs or Records

**** Setters

**** Withers

**** Builders

**** Constructors

*** More examples

**** Numbers

**** Text

**** Unique

**** Shuffle

**** Frequencies

**** Dependency injection
