#+STARTUP: indent
#+STARTUP: hidestars

#+PROPERTY: header-args :dir target/examples

#+PROPERTY: header-args:java  :cmdline -classpath .;../classes/
#+PROPERTY: header-args:java+ :cmpflag -classpath .;../classes/

** Introduction

Extends [[https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html][java.util.function.Supplier]] with higher-order methods for composition with other suppliers and transformation and filtering of the results produced by its functional method ~get~.

This project is stable, there won't be any breaking changes in new releases.

** Installation

Requires *Java 8* or higher.

*** Maven

#+begin_src xml
  <dependency>
    <groupId>io.sourceforge.recipe</groupId>
    <artifactId>recipe</artifactId>
    <version>1.0.3</version>
  </dependency>
#+end_src

*** Gradle

#+begin_src text
  implementation 'io.sourceforge.recipe:recipe:1.0.3'
#+end_src

** Examples

*** Preparation

**** Compile project

#+begin_src sh :dir . :results none
  mvn clean compile
#+end_src

**** Add imports needed for examples

#+begin_src java :noweb yes :tangle target/examples/ex/Examples.java :classname ex.Examples :results none :exports none
  package ex;

  import static ex.Examples.Beans.*;

  <<IMPORT>>

  public class Examples {

      // dummy main to avoid auto-generated one
      public static void main(String[] args) {}

      // --------------------------------------

      @FunctionalInterface
      public interface Executable {
          void execute() throws Throwable;
      }

      @SuppressWarnings("unchecked")
      public static <T extends Throwable> T assertThrows(Class<T> expectedType, Executable executable) {
          requireNonNull(expectedType);
          requireNonNull(executable);
          try {
              executable.execute();
          } catch (Throwable ex) {
              if (ex.getClass().equals(expectedType))
                  return (T) ex;
              throw new AssertionError("Expected: " + expectedType + " Actual: " + ex.getClass());
          }
          throw new AssertionError("Expected " + expectedType + " to be thrown but nothing was thrown");
      }

      private static final Beans __IGNORE = new Examples()
          .new Beans(new RoleService(),
                     new AccountService());

      <<STATIC>>

      // --------------------------------------

      public static void example1() {
          <<EXAMPLE_1>>
      }

      public static void example2() {
          <<EXAMPLE_2>>
      }

      public static void example3() {
          <<EXAMPLE_3>>
      }

      public static void example4() {
          <<EXAMPLE_4>>
      }

      public static void example5() {
          <<EXAMPLE_5>>
      }

      public static void example6() {
          <<EXAMPLE_6>>
      }

      public static void example7() {
          <<EXAMPLE_7>>
      }

      public static void example8() {
          <<EXAMPLE_8>>
      }

      public static void example9() {
          <<EXAMPLE_9>>
      }

      public static void example10() {
          <<EXAMPLE_10>>
      }

      public static void example11() {
          <<EXAMPLE_11>>
      }

      public static void example12() {
          <<EXAMPLE_12>>
      }

      public static void example13() {
          <<EXAMPLE_13>>
      }

      public static void example14() {
          <<EXAMPLE_14>>
      }

      public static void example15() {
          <<EXAMPLE_15>>
      }

      public static void example16() {
          <<EXAMPLE_16>>
      }

      public static void example17() {
          <<EXAMPLE_17>>
      }

      public static void example18() {
          <<EXAMPLE_18>>
      }

      public static void example19() {
          <<EXAMPLE_19>>
      }

      public static void example20() {
          <<EXAMPLE_20>>
      }

      public static void example21() {
          <<EXAMPLE_21>>
      }

      public static void example22() {
          <<EXAMPLE_22>>
      }

  }

  final class Account {

      private final Integer       id;
      private final String        username;
      private final LocalDateTime createdAt;

      public Account(Integer id, String username, LocalDateTime createdAt) {
          this.id        = id;
          this.username  = username;
          this.createdAt = createdAt;
      }

      public Integer       id       () { return id;        }
      public String        username () { return username;  }
      public LocalDateTime createdAt() { return createdAt; }

      public Account withId       (Integer       id       ) { return new Account(id, username, createdAt); }
      public Account withUsername (String        username ) { return new Account(id, username, createdAt); }
      public Account withCreatedAt(LocalDateTime createdAt) { return new Account(id, username, createdAt); }

      public static Builder builder() {
          return new Builder();
      }

      public static class Builder {

          private Integer       id;
          private String        username;
          private LocalDateTime createdAt;

          private Builder() {}

          public Builder id       (Integer       val) { id        = val; return this; }
          public Builder username (String        val) { username  = val; return this; }
          public Builder createdAt(LocalDateTime val) { createdAt = val; return this; }

          public Account build() {
              return new Account(id, username, createdAt);
          }

      }

      @Override
      public boolean equals(Object obj) {
          if (!(obj instanceof Account))
              return false;
          Account that = (Account) obj;
          return Objects.equals(id,        that.id)
              && Objects.equals(username,  that.username)
              && Objects.equals(createdAt, that.createdAt);
      }

      @Override
      public int hashCode() {
          return Objects.hash(id, username, createdAt);
      }

      @Override
      public String toString() {
          return "Account[id=" + id + ", username=" + username + ", createdAt=" + createdAt + ']';
      }

  }

  class Role {

      private Integer id;
      private String  name;

      public Role() {}

      public Role(Integer id, String name) {
          this.id   = id;
          this.name = name;
      }

      public Integer getId  () { return id;   }
      public String  getName() { return name; }

      public void setId  (Integer id)   { this.id   = id;   }
      public void setName(String  name) { this.name = name; }

      @Override
      public boolean equals(Object obj) {
          if (!(obj instanceof Role))
              return false;
          Role that = (Role) obj;
          return Objects.equals(id,   that.id)
              && Objects.equals(name, that.name);
      }

      @Override
      public int hashCode() {
          return Objects.hash(id, name);
      }

      @Override
      public String toString() {
          return "Role[id=" + id + ", name=" + name + ']';
      }

  }

  class RoleService {

      public List<Role> selectAll() {
          return asList(new Role(1, "admin"),
                        new Role(2, "editor"),
                        new Role(3, "designer"),
                        new Role(4, "viewer"));
      }

  }

  class AccountService {

      private static final AtomicInteger ID = new AtomicInteger();

      public Account save(Account account) {
          return account.withId(ID.incrementAndGet());
      }

      public void addRole(Account account, Role role) {}

  }
#+end_src

#+begin_src java :noweb-ref IMPORT :eval never
  import io.sourceforge.recipe.Recipe;
  import io.sourceforge.recipe.exception.RecipeFilterException;
  import io.sourceforge.recipe.util.Pair;

  import static io.sourceforge.recipe.util.Fn.*;

  import java.math.BigDecimal;
  import java.time.LocalDateTime;
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.HashMap;
  import java.util.List;
  import java.util.Map;
  import java.util.Objects;
  import java.util.UUID;
  import java.util.concurrent.atomic.AtomicInteger;
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.function.*;
  import java.util.stream.Stream;

  import static java.math.BigDecimal.ZERO;
  import static java.util.Arrays.asList;
  import static java.util.Collections.synchronizedList;
  import static java.util.Objects.requireNonNull;
  import static java.util.concurrent.ThreadLocalRandom.current;
  import static java.util.function.Function.identity;
  import static java.util.stream.Collectors.*;
#+end_src

*** Creating recipes

Recipe is a functional interface that extends the Supplier interface.
Both represent functions that accept nothing and return some value.
These functions are executed by calling their functional method ~get~.

**** Lambda expression

#+begin_src java :noweb-ref EXAMPLE_1 :eval never
  Supplier<String> sup = () -> "foo";
  Recipe  <String> rec = () -> "foo";

  System.out.println(
      sup.get().equals(rec.get())
  );
#+end_src

#+name: EXE_EXAMPLE_1
#+begin_src java :results output :exports results
  ex.Examples.example1();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_1
: true

**** Method reference

#+begin_src java :noweb-ref EXAMPLE_2 :eval never
  Recipe<UUID> rec = UUID::randomUUID;

  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_2
#+begin_src java :results output :exports results
  ex.Examples.example2();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_2
: 96a3732a-70ae-4d4a-9944-4bd39daf0af4
: 5d858623-8653-4c8a-90a9-b7cfdae043a5

**** Function to Recipe

Recipe extends Supplier by providing default methods for composition with other suppliers / recipes and transformation and filtering of the results produced by its method ~get~.

There is no way to chain those default method calls directly on the lambda expression / method reference such that the whole definition of a recipe is written as a single expression. One way to achieve this is to use the static method ~of~ as wrapper.

#+begin_src java :noweb-ref STATIC :eval never
  public static final Recipe<String>
      REC_UUID_STR = Recipe
          .of(UUID::randomUUID)
          .map(UUID::toString);
#+end_src

All Recipe's methods that accept other recipes as arguments, accept any extension of the Supplier instead of the concrete ~Recipe~ type. That's why the method ~of~ can also be used as converter to the ~Recipe~ type.

#+begin_src java :noweb-ref EXAMPLE_3 :eval never
  Supplier<UUID>    sup = UUID::randomUUID;
  Recipe  <Integer> rec = Recipe
                            .of(sup)
                            .map(UUID::toString)
                            .map(String::length);

  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_3
#+begin_src java :results output :exports results
  ex.Examples.example3();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_3
: 36

**** Reference Recipe

Recipe that constantly returns the given reference can be created with the static method ~ofValue~.

#+begin_src java :noweb-ref EXAMPLE_4 :eval never
  Recipe<List<Integer>> rec = Recipe
      .ofValue(asList(1, 2, 3));

  System.out.println(
      rec.get() == rec.get()
  );
#+end_src

#+name: EXE_EXAMPLE_4
#+begin_src java :results output :exports results
  ex.Examples.example4();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_4
: true

This method is also useful for creating stateful recipes.

#+begin_src java :noweb-ref EXAMPLE_5 :eval never
  Recipe<Long> rec = Recipe
      .ofValue(new AtomicLong())
      .map(AtomicLong::incrementAndGet);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_5
#+begin_src java :results output :exports results
  ex.Examples.example5();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_5
: 1
: 2
: 3

Recipe that constantly returns ~null~ can be created with the static method ~ofNull~.

**** Enum Recipe

Recipe that randomly chooses between constants of an Enum can be created with the static method ~ofEnum~.

#+begin_src java :noweb-ref STATIC :eval never
  public static enum ContactType {
      EMAIL, MOBILE_PHONE, LANDLINE
  }

  public static final Recipe<ContactType>
      REC_CONTACT_TYPE = Recipe
          .ofEnum(ContactType.class);
#+end_src

*** Composing recipes

**** Union

Recipe that randomly chooses a value from two recipes can be created with the method ~or~.

#+begin_src java :noweb-ref EXAMPLE_6 :eval never
  Recipe<Integer> rec = Recipe
      .of(() -> current().nextInt())
      .or(() -> null);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_6
#+begin_src java :results output :exports results
  ex.Examples.example6();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_6
: -1658766505
: 614352061
: null

For a union of variable number of recipes, use the static method ~oneOf~.

#+begin_src java :noweb-ref EXAMPLE_7 :eval never
  Recipe<String> rec = Recipe
      .oneOf(() -> "foo",
             REC_UUID_STR,
             Recipe.ofValue("bar"),
             REC_CONTACT_TYPE.map(ContactType::name));

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_7
#+begin_src java :results output :exports results
  ex.Examples.example7();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_7
: bar
: 37d16e60-e337-47c4-b214-41bcbbb962d1
: be1dcfc8-f5f1-476e-87e6-0ec8ff0e24e9
: MOBILE_PHONE

**** Filtering

Use the method ~filter~ to create a new recipe that returns only those values, produced by the underlying recipe, that match a predicate.

#+begin_src java :noweb-ref EXAMPLE_8 :eval never
  Recipe<Double> rec = Recipe
      .of(() -> current().nextDouble())
      .filter(x -> x > 0)
      .filter(x -> !x.isInfinite());

  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_8
#+begin_src java :results output :exports results
  ex.Examples.example8();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_8
: 0.12826014636372696
: 0.3920702845614149

When the given predicate cannot be satisfied after 100 tries, runtime exception ~RecipeFilterException~ is thrown.

#+begin_src java :noweb-ref EXAMPLE_9 :eval never
  Recipe<Integer> rec = Recipe
      .of(() -> current().nextInt())
      .filter(x -> x > 0 && x < 6);

  try {
      rec.get();
  } catch (RecipeFilterException ex) {
      System.out.println(ex.getMessage());
  }
#+end_src

#+name: EXE_EXAMPLE_9
#+begin_src java :results output :exports results
  ex.Examples.example9();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_9
: Couldn't satisfy predicate after 100 tries.

This can be fixed either by improving the underlying recipe (e.g., use ~nextInt(1, 6)~ instead of unbounded ~nextInt()~) or by relaxing the predicate.

**** Transformation

Use the method ~map~ to create a new recipe that applies a function to the values produced by the underlying recipe.

If the given function has side effects, it is often ~void~ or returns some other type that you might want to ignore.
Use the helper method [[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/io/sourceforge/recipe/util/Fn.java#L21][Fn#doto]] to apply the function to the object and return that same object.

#+begin_src java :noweb-ref EXAMPLE_10 :eval never
  Recipe<List<Integer>> rec = Recipe
      .ofValue(asList(1, 2, 3, 4, 5))     // unmodifiable list
      .map(ArrayList::new)                // make modifiable copy
      .map(doto(list -> list.add(42)))    // add method returns boolean
      .map(doto(Collections::shuffle))    // shuffle method is void
      .map(Collections::unmodifiableList) // make unmodifiable list
      .map(doto(System.out::println));    // println method is void

  rec.get();
  rec.get();
#+end_src

#+name: EXE_EXAMPLE_10
#+begin_src java :results output :exports results
  ex.Examples.example10();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_10
: [3, 42, 5, 2, 1, 4]
: [2, 5, 3, 1, 4, 42]

**** Binding

Use the method ~bind~ to create a new recipe that takes values produced by two recipes and combines them with a binary function. There are three common cases:

***** Second recipe depends on values produced by the first recipe

For example, recipe that takes a random element from a list - the first recipe produces a list of elements, the second an index based on the size of the produced list. Binary function uses those values to retrieve an element.

#+begin_src java :noweb-ref EXAMPLE_11 :eval never
  Recipe<Object> rec = Recipe
      .oneOf(() -> asList(1, 2, 3, 4),
             () -> asList("foo", "bar", "baz"))
      .bind(list -> () -> current().nextInt(0, list.size()), List::get);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_11
#+begin_src java :results output :exports results
  ex.Examples.example11();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_11
: bar
: baz
: 4

This is a very common pattern. To make it more readable, creation of the second recipe can be written as a method reference, with the help of static method ~recIndex~.

#+begin_src java :noweb-ref STATIC :eval never
  public static Recipe<String>
      REC_EMAIL_DOMAIN = Recipe
          .ofValue(asList("gmail.com", "yahoo.com", "proton.me"))
          .bind(Examples::recIndex, List::get);

  public static Recipe<Integer> recIndex(List<?> list) {
      if (list.isEmpty())
          throw new IllegalArgumentException("empty list");
      return () -> current().nextInt(0, list.size());
  }
#+end_src

If the first recipe depends on the value produced by the second recipe, then swap their order.

***** Recipes do not depend on each other

For example, an email address consists of two parts, a local part and a domain, joined with the symbol ~@~. Both parts can be generated independently. Helper method [[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/io/sourceforge/recipe/util/Fn.java#L84][Fn#recfn]] can be used instead of function with ignored argument.

#+begin_src java :noweb-ref EXAMPLE_12 :eval never
  Recipe<String> recEmail =
      REC_UUID_STR
          .map(local -> local.substring(0, 8))
          .bind(recfn(REC_EMAIL_DOMAIN), // __ -> REC_EMAIL_DOMAIN
                (local, domain) -> local + "@" + domain);

  System.out.println(recEmail.get());
  System.out.println(recEmail.get());
#+end_src

#+name: EXE_EXAMPLE_12
#+begin_src java :results output :exports results
  ex.Examples.example12();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_12
: bdd27ccd@gmail.com
: 559c052c@yahoo.com

***** Second recipe produces results of function application

For example, recipe that produces a pair of a list and the maximum element from that list. Helper method [[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/io/sourceforge/recipe/util/Fn.java#L96][Fn#fnrec]] can be used to wrap a function so that it returns a constant recipe of its result.

#+begin_src java :noweb-ref EXAMPLE_13 :eval never
  Recipe<Pair<List<Integer>, Integer>> rec = Recipe
      .ofValue(asList(1, 9, 3, 5, 7))
      // list -> Recipe.ofValue(Collections.max(list))
      .bind(fnrec(Collections::max), Pair::new);

  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_13
#+begin_src java :results output :exports results
  ex.Examples.example13();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_13
: Pair[first=[1, 9, 3, 5, 7], second=9]

In any of the cases above, it may happen that the binary function has side effects. Such function is often ~void~ or returns some other type that you might want to ignore. Use the helper method [[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/io/sourceforge/recipe/util/Fn.java#L36][Fn#dotwo]] to apply the function to the given objects and return the pair of those objects. If you need only the first argument provided to the binary function, use [[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/io/sourceforge/recipe/util/Fn.java#L52][Fn#biFirst]]. If you need only the second argument, use [[https://github.com/nikolavojicic/recipe/blob/master/src/main/java/io/sourceforge/recipe/util/Fn.java#L68][Fn#biSecond]].

#+begin_src java :noweb-ref EXAMPLE_14 :eval never
  Recipe<List<Integer>> rec = Recipe
      .ofValue(synchronizedList(new ArrayList<Integer>()))
      .bind(recfn(Recipe
                  .ofValue(new AtomicInteger())
                  .map(AtomicInteger::incrementAndGet)),
            biFirst(List::add)) // add returns boolean
      // .map(List::copyOf) in Java 10+
      .map(ArrayList::new)
      .map(Collections::unmodifiableList);

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_14
#+begin_src java :results output :exports results
  ex.Examples.example14();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_14
: [1]
: [1, 2]
: [1, 2, 3]

**** Wrapping

Use the method ~wrap~ to create a new recipe that applies a function to the underlying recipe.

This is commonly used with [[https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#generate-java.util.function.Supplier-][Stream#generate]], which creates an infinite stream of values produced by the provided supplier / recipe.

#+begin_src java :noweb-ref EXAMPLE_15 :eval never
  Recipe<List<Integer>> rec = recInt(-100, 100)
      .wrap(Stream::generate)
      .bind(recfn(recInt(1, 6)), Stream::limit)
      .map(stream -> stream.collect(toList()));

  System.out.println(rec.get());
  System.out.println(rec.get());
  System.out.println(rec.get());
#+end_src

#+name: EXE_EXAMPLE_15
#+begin_src java :results output :exports results
  ex.Examples.example15();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_15
: [26, -68, -90, -23, 65]
: [85, -30, 82, 10, -4]
: [69, 64, -58]

Handling runtime exceptions is another use case, e.g., with JUnit's [[https://junit.org/junit5/docs/5.8.2/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html#assertThrows(java.lang.Class,org.junit.jupiter.api.function.Executable)][Assertions#assertThrows]].

#+begin_src java :noweb-ref EXAMPLE_16 :eval never
  REC_INT
      .map(x -> x / 0) // divide by zero!
      .wrap(rec -> assertThrows(ArithmeticException.class, rec::get))
      .map(ArithmeticException::getMessage)
      .map(doto(System.out::println))
      .get();
#+end_src

#+name: EXE_EXAMPLE_16
#+begin_src java :results output :exports results
  ex.Examples.example16();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_16
: / by zero

**** Flattening

Whenever a (binary) function provided to ~map~ or ~bind~ returns a recipe, the overall recipe type can be flattened (from ~Recipe<Recipe<T>>~ to ~Recipe<T>~) by chaining an additional ~.map(Recipe::get)~ call, while preserving the same behavior.

Recipe for recipes is useful for creating unions of recipes. The example bellow is similar to the method ~oneOf~ but it accepts weight for each recipe to determine the frequency of picking that recipe.

#+begin_src java :noweb-ref STATIC :eval never
  public static <T> Recipe<T> recFreq(Map<? extends Supplier<? extends T>, Integer> frequencies) {
      // naive implementation
      List<Recipe<? extends T>> recipes = frequencies
          .entrySet().stream()
          .filter(e -> e.getValue() > 0)
          .flatMap(e -> Stream.generate(e::getKey).limit(e.getValue()))
          .map(Recipe::of)
          .collect(toList());
      if (recipes.isEmpty())
          throw new IllegalArgumentException("No positive frequencies.");
      return Recipe
          .ofValue(recipes)
          .bind(Examples::recIndex, List::get)
          .map(Recipe::get); // flatten
  }
#+end_src

For example, recipe that produces ~foo~ 50%, ~bar~ 20% and ~baz~ 30% of the time.

#+begin_src java :noweb-ref EXAMPLE_17 :eval never
  Map<Recipe<String>, Integer> frequencies = new HashMap<>();
  frequencies.put(() -> "foo", 5);
  frequencies.put(() -> "bar", 2);
  frequencies.put(() -> "baz", 3);

  Stream
      .generate(recFreq(frequencies))
      .limit(1000)
      .collect(groupingBy(identity(), counting()))
      .forEach((k, v) -> System.out.printf("%s was generated %d times\n", k, v));
#+end_src

#+name: EXE_EXAMPLE_17
#+begin_src java :results output :exports results
  ex.Examples.example17();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_17
: foo was generated 494 times
: bar was generated 199 times
: baz was generated 307 times

*** Generating numbers

**** Bounded

Methods of the class [[https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadLocalRandom.html][ThreadLocalRandom]] are used here, but you can delegate to any number generator.

#+begin_src java :noweb-ref STATIC :eval never
  public static Recipe<Integer> recInt(int origin, int bound) {
      current().nextInt(origin, bound); // check constraints
      return () -> current().nextInt(origin, bound);
  }

  public static Recipe<Long> recLong(long origin, long bound) {
      current().nextLong(origin, bound); // check constraints
      return () -> current().nextLong(origin, bound);
  }

  public static Recipe<Double> recDouble(double origin, double bound) {
      current().nextDouble(origin, bound); // check constraints
      return () -> current().nextDouble(origin, bound);
  }

  public static Recipe<BigDecimal> recBigdec(double origin, double bound) {
      return recDouble(origin, bound)
          .filter(Double::isFinite)
          .map(BigDecimal::valueOf);
  }

  public static Recipe<BigDecimal> recBigdec(BigDecimal origin, BigDecimal bound) {
      return recBigdec(origin.doubleValue(), bound.doubleValue());
  }
#+end_src

**** Without bound params

Note that these recipes produce less random values, e.g., any union (~or~, ~oneOf~) with the ~_ZERO_~ recipe will generate zeros more frequently. This behavior can be useful though, because zero is an edge case.

#+begin_src java :noweb-ref STATIC :eval never
  public static final Recipe<Integer>
      REC_INT_POS  = recInt(0, Integer.MAX_VALUE).map(x -> x + 1),
      REC_INT_NEG  = recInt(Integer.MIN_VALUE, 0),
      REC_INT_ZERO = Recipe.ofValue(0),
      REC_INT_NAT  = REC_INT_POS.or(REC_INT_ZERO),
      REC_INT      = Recipe.oneOf(REC_INT_NEG, REC_INT_ZERO, REC_INT_POS);

  public static final Recipe<Long>
      REC_LONG_POS  = recLong(0, Long.MAX_VALUE).map(x -> x + 1),
      REC_LONG_NEG  = recLong(Long.MIN_VALUE, 0),
      REC_LONG_ZERO = Recipe.ofValue(0L),
      REC_LONG_NAT  = REC_LONG_POS.or(REC_LONG_ZERO),
      REC_LONG      = Recipe.oneOf(REC_LONG_NEG, REC_LONG_ZERO, REC_LONG_POS);

  public static final Recipe<Double>
      REC_DOUBLE_POS  = Recipe.of(() -> current().nextDouble()).filter(x -> x != 0).map(Math::abs),
      REC_DOUBLE_NEG  = REC_DOUBLE_POS.map(x -> -x),
      REC_DOUBLE_ZERO = Recipe.ofValue(0.0),
      REC_DOUBLE_NAT  = REC_DOUBLE_POS.or(REC_DOUBLE_ZERO),
      REC_DOUBLE      = Recipe.oneOf(REC_DOUBLE_NEG, REC_DOUBLE_ZERO, REC_DOUBLE_POS);

  public static final Recipe<BigDecimal>
      REC_BIGDEC_POS  = REC_DOUBLE_POS.filter(Double::isFinite).map(BigDecimal::valueOf),
      REC_BIGDEC_NEG  = REC_BIGDEC_POS.map(BigDecimal::negate),
      REC_BIGDEC_ZERO = Recipe.ofValue(ZERO),
      REC_BIGDEC_NAT  = REC_BIGDEC_POS.or(REC_BIGDEC_ZERO),
      REC_BIGDEC      = Recipe.oneOf(REC_BIGDEC_NEG, REC_BIGDEC_ZERO, REC_BIGDEC_POS);

  public static final Recipe<Number>
      REC_NUMBER_POS  = Recipe.oneOf(REC_INT_POS,  REC_LONG_POS,  REC_DOUBLE_POS,  REC_BIGDEC_POS),
      REC_NUMBER_NEG  = Recipe.oneOf(REC_INT_NEG,  REC_LONG_NEG,  REC_DOUBLE_NEG,  REC_BIGDEC_NEG),
      REC_NUMBER_ZERO = Recipe.oneOf(REC_INT_ZERO, REC_LONG_ZERO, REC_DOUBLE_ZERO, REC_BIGDEC_ZERO),
      REC_NUMBER_NAT  = Recipe.oneOf(REC_INT_NAT,  REC_LONG_NAT,  REC_DOUBLE_NAT,  REC_BIGDEC_NAT),
      REC_NUMBER      = Recipe.oneOf(REC_INT,      REC_LONG,      REC_DOUBLE,      REC_BIGDEC);
#+end_src

*** Generating text

Because strings are arrays of characters, the most general approach is to start with recipes for characters. Recipe for strings can than ~wrap~ recipe for characters to produce a stream of characters and collect that stream into a string by concatenation.

#+begin_src java :noweb-ref STATIC :eval never
  public static final List<Character>
      NUMERIC = asList
      ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9'),
      ALPHABET = asList
      ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
       'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'),
      WHITESPACE = asList
      (' ', '\t', '\n', '\r');

  public static final Recipe<Character>
      REC_ALPHA_UPPER  = Recipe
                          .ofValue(ALPHABET)
                          .bind(Examples::recIndex, List::get),
      REC_ALPHA_LOWER  = REC_ALPHA_UPPER
                          .map(Character::toLowerCase),
      REC_ALPHA        = REC_ALPHA_UPPER
                          .or(REC_ALPHA_LOWER),
      REC_NUMERIC      = Recipe
                          .ofValue(NUMERIC)
                          .bind(Examples::recIndex, List::get),
      REC_ALPHANUMERIC = REC_ALPHA
                          .or(REC_NUMERIC),
      REC_WHITESPACE   = Recipe
                          .ofValue(WHITESPACE)
                          .bind(Examples::recIndex, List::get);

  public static Recipe<String> recString(Supplier<? extends Character> recipe, int maxLength) {
      return Recipe
          .of(recipe)
          .map(Object::toString)
          .wrap(Stream::generate)
          .bind(recfn(recInt(0, maxLength).map(x -> x + 1)), Stream::limit)
          .map(s -> s.collect(joining()));
  }
#+end_src

Method ~recString~ accepts any recipe for characters (or any union of such recipes) and the maximum length of the produced string. Here we are generating alphanumeric text with whitespaces:

#+begin_src java :noweb-ref EXAMPLE_18 :eval never
  Map<Recipe<Character>, Integer> frequencies = new HashMap<>();
  frequencies.put(REC_ALPHANUMERIC, 9);
  frequencies.put(REC_WHITESPACE,   1);

  recString(recFreq(frequencies), 500)
      .map(doto(System.out::println))
      .get();
#+end_src

#+name: EXE_EXAMPLE_18
#+begin_src java :results output :exports results :wrap src
  ex.Examples.example18();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_18
#+begin_src
Hm18Cr 98
l526de54d7T160
5QO23BaxV1Uz54539SDFU4C0p
T3fs1TvV437oDT012Ny120fjIy6
E
68eZyb
S7V
3wZ7G0b6W972	6Kg4y333t0l
i	f31W5b	U6pT908yYm1P	2llro2jC8m0989Mq9869
mj05aE17z 8P9
#+end_src

*** Generating POJOs or records

To generate builders and withers for Java 14 records, you can use [[https://github.com/Randgalt/record-builder][this library]].

**** Builders

#+begin_src java :noweb-ref STATIC :eval never
  public static final Recipe<Account> REC_ACCOUNT = Recipe
      .of(Account::builder)
      .bind(recfn(recString(REC_ALPHANUMERIC, 10)), Account.Builder::username)
      .bind(recfn(LocalDateTime::now),              Account.Builder::createdAt)
      .map(Account.Builder::build);
#+end_src

**** Withers

#+begin_src java :noweb-ref STATIC :eval never
  public static final Recipe<Account> REC_ACCOUNT_WITH_INVALID_ID =
      REC_ACCOUNT
          .bind(recfn(REC_INT_NEG), Account::withId);
#+end_src

**** Setters

#+begin_src java :noweb-ref STATIC :eval never
  public static final Recipe<Role> REC_ROLE = Recipe
      .of(Role::new)
      .bind(recfn(REC_UUID_STR), biFirst(Role::setName));
#+end_src

**** Constructors

Constructors with one argument are functions that can be used with the method ~map~.

#+begin_src java :noweb-ref EXAMPLE_19 :eval never
  Recipe<BigDecimal> rec = Recipe.ofValue("3.14").map(BigDecimal::new);
#+end_src

Constructors with two arguments are binary functions that can be used with the method ~bind~.

#+begin_src java :noweb-ref EXAMPLE_20 :eval never
  Recipe<Role> rec = REC_INT_POS.bind(recfn(REC_UUID_STR), Role::new);
#+end_src

If the only option is a constructor with more than two arguments, generation is still possible, but ugly.

#+begin_src java :noweb-ref EXAMPLE_21 :eval never
  Recipe<Account> rec = Recipe
      .of(() -> new Account(null,
                            recString(REC_ALPHANUMERIC, 10).get(),
                            LocalDateTime.now()));
#+end_src

*** Dependency injection

When testing, I prefer to keep reusable recipes as ~static final~ fields in separate, non-instantiable classes.

Recipes may depend on "injected" objects that provide logic for side effects, such as selecting data from the database, inserting new data etc. Even though dependency injection in [[https://spring.io/][Spring]] leans toward non-static fields, there is a workaround that enables injection into static fields.

#+begin_src java :noweb-ref STATIC :eval never
  // Uncomment comments below

  // @org.springframework.stereotype.Component
  public class Beans {

      public static RoleService    roleService;
      public static AccountService accountService;

      // @org.springframework.beans.factory.annotation.Autowired
      public Beans(RoleService    roleService,
                   AccountService accountService)
      {
          Beans.roleService    = roleService;
          Beans.accountService = accountService;
      }

  }
#+end_src

Now it is possible to use these services in static contexts.

#+begin_src java :noweb-ref STATIC :eval never
  public static final Recipe<Role> REC_ROLE_SAVED = Recipe
      .ofValue(roleService.selectAll())
      .bind(Examples::recIndex, List::get);

  public static final Recipe<Account> REC_ACCOUNT_SAVED =
      REC_ACCOUNT
          .map(accountService::save);

  public static final Recipe<Pair<Account, Role>> REC_ACCOUNT_WITH_ROLE =
      REC_ACCOUNT_SAVED
          .bind(recfn(REC_ROLE_SAVED), dotwo(accountService::addRole));
#+end_src

Note that ~REC_ROLE_SAVED~ selects all the roles only once, because ~ofValue~ is used.

#+begin_src java :noweb-ref EXAMPLE_22 :eval never
  REC_ACCOUNT_WITH_ROLE
      .map(doto(System.out::println))
      .get();
#+end_src

#+name: EXE_EXAMPLE_22
#+begin_src java :results output :exports results
  ex.Examples.example22();
#+end_src

Results:
#+RESULTS: EXE_EXAMPLE_22
: Pair[first=Account[id=1, username=a6mSFp5, createdAt=2022-07-26T04:04:52.020284], second=Role[id=2, name=editor]]

Some people warn against this workaround mostly because of possible initialization gotchas. In my experience so far, there won’t be any problems if you keep static injections, static recipe definitions and tests in separate classes.

** License

For the source code see the [[https://github.com/nikolavojicic/recipe/blob/master/LICENSE][LICENSE]] file.

You can freely copy any code from this [[https://github.com/nikolavojicic/recipe#readme][README.org]] file.
