// Copyright (c) Nikola Vojičić

package org.recipe;

import org.recipe.exception.GeneratorFilterException;

import java.util.ArrayList;
import java.util.List;
import java.util.function.*;

import static java.util.Objects.requireNonNull;
import static java.util.concurrent.ThreadLocalRandom.current;

@FunctionalInterface
public interface Generator<T> extends Supplier<T> {

    /**
     * @return generator with values transformed by {@code mapper}
     * @throws NullPointerException if {@code mapper} is {@code null}
     */
    default <R> Generator<R>
        map
            (Function<? super   T,
                      ? extends R> mapper)
    {
        requireNonNull(mapper);
        return () -> mapper.apply(get());
    }

    /**
     * @return flattened generator with values transformed by {@code mapper}
     * @throws NullPointerException if {@code mapper} is {@code null}
     */
    default <R> Generator<R>
        flatMap
            (Function<? super   T,
                      ? extends Generator<? extends R>> mapper)
    {
        requireNonNull(mapper);
        return () -> mapper.apply(get()).get();
    }

    /**
     * @return generator with values consumed by {@code action}
     * @throws NullPointerException if {@code action} is {@code null}
     */
    default Generator<T>
        mapEffect
            (Consumer<? super T> action)
    {
        requireNonNull(action);
        return () -> {
            T value = get();
            action.accept(value);
            return value;
        };
    }

    /**
     * @return generator that applies {@code binder} to values generated by {@code this} and {@code generator}
     * @throws NullPointerException if {@code generator} or {@code binder} is {@code null}
     */
    default <U, R> Generator<R>
        bind
            (Generator <? extends U> generator,
             BiFunction<? super   T,
                        ? super   U,
                        ? extends R> binder)
    {
        requireNonNull(generator);
        requireNonNull(binder);
        return () -> binder.apply(get(), generator.get());
    }

    /**
     * @return flattened generator that applies {@code binder} to values generated by {@code this} and {@code generator}
     * @throws NullPointerException if {@code generator} or {@code binder} is {@code null}
     */
    default <U, R> Generator<R>
        flatBind
            (Generator <? extends U> generator,
             BiFunction<? super   T,
                        ? super   U,
                        ? extends Generator<? extends R>> binder)
    {
        requireNonNull(generator);
        requireNonNull(binder);
        return () -> binder.apply(get(), generator.get()).get();
    }

    /**
     * @return generator that returns value generated by {@code this} which is previously consumed by {@code binder}
     *         along with value generated by {@code generator}
     * @throws NullPointerException if {@code generator} or {@code binder} is {@code null}
     */
    default <U> Generator<T>
        bindEffect
            (Generator <? extends U> generator,
             BiConsumer<? super   T,
                        ? super   U> binder)
    {
        requireNonNull(generator);
        requireNonNull(binder);
        return () -> {
            T value = get();
            binder.accept(value, generator.get());
            return value;
        };
    }

    /**
     * @return generator with values filtered by {@code predicate}
     * @throws NullPointerException if {@code predicate} is {@code null}
     * @throws GeneratorFilterException if {@code predicate} returns {@code false} for 100 values in a row
     */
    default Generator<T>
        filter
            (Predicate<? super T> predicate)
    {
        requireNonNull(predicate);
        return () -> {
            int tries = 0;
            while (tries < 100) {
                T value = get();
                if (predicate.test(value))
                    return value;
                tries++;
            }
            throw new GeneratorFilterException(
                    "Couldn't satisfy predicate after 100 tries.");
        };
    }

    /**
     * @return generator that randomly chooses between {@code this} and {@code generator}
     * @throws NullPointerException if {@code generator} is {@code null}
     */
    default Generator<T>
        or
            (Generator<? extends T> generator)
    {
        requireNonNull(generator);
        return () -> current().nextBoolean()
                ? get()
                : generator.get();
    }

    /**
     * @return generator that applies {@code lifter} to {@code this}
     * @throws NullPointerException if {@code lifter} is {@code null}
     */
    default <R> Generator<R>
        lift
            (Function<? super   Generator<? extends T>,
                      ? extends R>                      lifter)
    {
        requireNonNull(lifter);
        return () -> lifter.apply(this);
    }

    // ---------------- FACTORIES ----------------

    /**
     * @return given {@code generator}
     * @throws NullPointerException if {@code generator} is {@code null}
     */
    static <T> Generator<T>
        of
            (Generator<T> generator)
    {
        return requireNonNull(generator);
    }

    /**
     * @return generator that constantly returns {@code value}
     */
    static <T> Generator<T>
        ofValue
            (T value)
    {
        return () -> value;
    }

    /**
     * @return generator that randomly chooses between {@code generators}
     * @throws IllegalArgumentException if {@code generators} is empty
     * @throws NullPointerException if any of {@code generators} is {@code null}
     */
    @SafeVarargs
    static <T> Generator<T>
        oneOf
            (Generator<? extends T>... generators)
    {
        if (generators.length == 0)
            throw new IllegalArgumentException("Empty generators");
        List<Generator<? extends T>> generatorList = new ArrayList<>();
        for (Generator<? extends T> generator : generators)
            generatorList.add(requireNonNull(generator));
        return () -> generatorList
                .get(current().nextInt(0, generatorList.size()))
                .get();
    }

}
